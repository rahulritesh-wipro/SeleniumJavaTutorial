1) Introduction
2) Runtime Stack Mechanism
3) Default Exception Handling in Java
4) Exception Hierarchy
5) Customized Exception Handling by using try & catch
6) Control Flow in try & catch
7) Methods to Print Exception Information
8) try with Multiple catch Blocks
9) finally Block
10) Difference between final, finally & finalize()
11) Various Possible Combinations of try-catch-finally
12) Control Flow in try-catch-finally
13) Control Flow in Nested try-catch-finally
14) throw Key Word
15) throws Key Word
16) Exception Handling Key Words Summary
17) Various Possible Compile-Time Errors in Exception Handling
18) Customized OR User defined Exceptions
19) Top 10 Exception
20) 1.7 Version Enhancements
 try with Resources
 Multi- catch Block


Introduction

Q) What is an Exception?
Q) What is the Purpose of Exception Handling?
Q) What is the Meaning of Exception Handling?

 An Unwanted Unexpected Event that Disturbs Normal Flow of the Program is Called Exception.
Eg: SleepingException, TyrePuncheredException, FileNotFoundException Etc…

 It is Highly Recommended to Handle Exceptions.

 The Main Objective of Exception Handling is Graceful Termination of the Program.
i.e. we should Not Miss anything, we should Not Block any Resource.


Exception Handling:
 Exception Handling doesn’t mean repairing an Exception. instead We have to define an Alternative Way to Continue Rest of the Program Normally.
 This Way of defining Alternative is nothing but Exception Handling.

 For Example--------
if Our Programming Requirement is to Read Data from the File locating at London.
At Runtime if London File is Not Available then Our Program should Not be terminated Abnormally.
We have to provide Some Local File to Continue Rest of the Program Normally. 
This Way of defining Alternative is nothing but Exception Handling.

try {
//Read Data from Remote File locating at London
}
catch (FileNotFoundException e) {
//Use Local File and Continue Rest of the Program Normally
}



Runtime Stack Mechanism
1 For Every Thread JVM will Create a Runtime Stack. Stack - LIFO Last In First Out
2 Every Method Call performed by that Thread will be stored in the Corresponding Stack.
3 Each Entry in the Stack is Called Activation Record OR Stack Frame.
4 After completing Every Method Execution JVM Removes the Corresponding Entry from the Stack.
5 After completing all Method Calls the Stack become Empty and that Empty Stack will be Destroyed by the JVM and the Program will be terminated Normally.

Example---
class Test {
public static void main(String[] args) {
doStuff();
}
public static void doStuff() {
doMoreStuff();
}
public static void doMoreStuff() {
System.out.println("Hello"); //Hello
}
}



                                                    doMoreStuff()------
                                    doStuff()------ doStuff()---------- doStuff()
Runtime Stack-------main()----------main()----------main()--------------main()------main()---Runtime Stack
                    activation record                                                         Empty stack will be destroyed by JVM
                       or
                    Stack Frame 



Default Exception Handling in Java-------------------------------------------------------------------
> In Our Java Program Inside a Method if an Exception raised, then that Method is Responsible to Create an Exception Object by including the following Information.
1 Name of Exception
2 Description of Exception
3 Location of Exception (Stack Trace)


> After creating Exception Object Method Handovers that Object to the JVM.
> JVM will Check whether Corresponding Method contain any Exception Handling Code OR Not.
> If the Method doesn't contain any Exception Handling Code then JVM Terminates that Method Abnormally and Removes Corresponding Entry from the Stack.
> JVM will Identify Caller Method and Check whether the Caller Method contain any Exception Handle Code OR Not.
> If Caller Method doesn't contain any Exception Handling Code then JVM Terminates that Caller Method and Removes Corresponding Entry from the Stack.
> This Process will be continued until main().
> If the main() also doesn't contain Exception Handling Code then JVM Terminates main() Abnormally and Removes Corresponding Entry from the Stack.

> Then JVM Handovers the Responsibility of Exception Handling to the Default Exception Handler, which is the Part of the JVM.
> Default Exception Handler Just Terminates the Program Abnormally and Prints Exception Information to the Console in the following Format.
Exception in thread: “Xxx” Name of the Exception: Description
Stack Trace

Examples:

class Test {
public static void main(String[] args) {
doStuff();
}
public static void doStuff() {
doMoreStuff();
}
public static void doMoreStuff() {
System.out.println(10/0);
}
}
RE: Exception in thread "main" java.lang.ArithmeticException: / by zero                            doMoreStuff()
at Test.doMoreStuff(Test.java:9)                                                                   doStuff()
at Test.doStuff(Test.java:6)                                                                       main()
at Test.main(Test.java:3)                                                                          RuntimeStack

Example 2-------------
class Test {
public static void main(String[] args) {
doStuff();
}
public static void doStuff() {
doMoreStuff();
System.out.println(10/0);
}
public static void doMoreStuff() {
System.out.println("Hello");
}
}

Hello
Exception in thread "main" java.lang.ArithmeticException: / by zero
at Test.doStuff(Test.java:7)
at Test.main(Test.java:3)

Example 3----------

class Test {
public static void main(String[] args) {
doStuff();
System.out.println(10/0);
}
public static void doStuff() {
doMoreStuff();
System.out.println("Hi");
}
public static void doMoreStuff() {
System.out.println("Hello");
}
}

Hello
Hi
Exception in thread "main" java.lang.ArithmeticException: / by zero
at Test.main(Test.java:4)

Note:
 In Our Program if all Methods Terminated Normally, then Only the Program will be Terminated Normally.
 In Our Program if at least One Method terminates Abnormally then the Program Termination is Abnormal Termination.

Exception Hierarchy ------------------------------------------------------------------
> Throwable Class Acts as Root for Exception Hierarchy.
> Throwable Class contains 2 Child Classes Exception and Error

Exception:
Most of the Cases Exceptions are Caused by Our Program and these are Re- Coverable.
Eg:
 If Our Programming Requirement is to Read Data from the File locating at London.
 At Runtime if London File is Not Available then we get FileNotFoundException.
 If FileNotFoundException Occurs we can Provide Local File to Continue Rest of the Program Normally.
 Programmer is Responsible to Recover Exception.


Error:
 Most of the Cases Errors are Not Caused by Our Program and these are Due to Lack of System Resources.
 Errors are Non- Recoverable.
Eg:
 If OutOfMemoryError Occurs, being a Programmer we can't do anything and the Program will be terminated Abnormally.
 System Admin OR Server Admin is Responsible to Increase Heep Memory.




Checked Vs Unchecked Exception:
Checked Exceptions:
> The Exceptions which are Checked by the Compiler for Smooth Execution of the Program at Runtime are Called Checked Exceptions.
> Compiler Checks whether we are handling Checked Exceptions OR Not. If we are Not handling then we will get Compile Time Error.
Eg:
HallTicketMissingException, PenNotWorkingException, FileNotFoundException, Etc.

Unchecked Exceptions:
> The Exceptions which are Not Checked by the Compiler are Called Unchecked Exception.
> Compiler won't Check whether we are Handle OR Not Unchecked Exceptions.
Eg: ArithmeticException, NullPointerException, BombBlostException, Etc.

Note:
1 Whether the Exception is Checked OR Unchecked Compulsory it will Occur at Runtime Only.
2 There is No Chance of occurring any Exception at Compile Time.
3 Runtime Exceptions and its Child Classes, Errors and its Child Classes are Unchecked Exceptions Except these all remaining are Considered as Checked Exceptions


                                              Throwable

               Exception                                                                                           Error

RuntimeException                    IOException           InterruptedException      RemoteException          VirtualMachineError         LinkageError       AssertionError
                                                                                                                --- OutOfMemoryError        --- VerifyError
                                         ---EOFException                                                        --- StackOverFlowError
                                         ---FileNotFoundException                                                      
ArithmeticException                      ---InterruptedIOException
NullPointerException
ClassCastException

IndexOutOfBoundsException - 
             ------  StringIndexOutOfBoundsException
             ------  ArrayIndexOutOfBoundsException   
IllegalArgumentException
    ----------NumberFormatException

IllegalStateException
  -----IllegalThreadStateException
  -----IllegalMonitorStateException



Fully Checked Vs Partially Checked: -----------------------------------------------

A Checked Exception is Said to be Fully Checked if and Only if all its Child Classes also Checked.
Eg: IOException, InterruptedException, ServletException, Etc...

A Checked Exception is Said to be Partially Checked if and Only if Some of its Child Classes are Unchecked.
Eg: Throwable, Exception.

Note: The Only Possible Partially Checked Exceptions in Java are
☀ Throwable
☀ Exception

Describe the Behaviour of the following Exceptions
1) IOException  Fully Checked
2) RuntimeException  Unchecked
3) InterruptedException  Fully Checked
4) Error  Unchecked
5) Throwable  Partially Checked
6) ArithmeticException  Unchecked
7) NullPointerException  Unchecked
8) Exception  Partially Checked
9) FileNotFoundException  Fully Checked


Customized Exception Handling by using try - catch---------------------------
> It is Highly Recommended to Handle Exceptions.
> The Code which May Raise an Exception is Called Risky Code.
> We have to Place that Risky Code Inside try Block and Corresponding Handle Code Inside catch Block.


try
{
//Risky Code
}
catch (Exception e)
{
//Handling Code
}


Example And Cases---------------------------------------------------


Without try – catch  - Abnormal Termination
class Test {
public static void main(String[] args) {
System.out.println("Statement 1");
System.out.println(10/0);
System.out.println("Statement 2");
}
}

Statement 1
RE: Exception in thread "main" java.lang.ArithmeticException: / by zero
at Test.main(Test.java:4)

##############################################################################

With try - catch  --- Normal Termination

class Test {
public static void main(String[] args) {
System.out.println("Statement 1");
try {
System.out.println(10/0);
}
catch(ArithmeticException e) {
System.out.println(10/2);
}
System.out.println("Statement 2");
}
}


Statement 1
5
Statement 2


Control Flow in try – catch: ---------------------------
try {
Statement 1;
Statement 2;
Statement 3;
}
catch(X e) {
Statement 4;
}
Statement 5;


Case 1: If there is No Exception  1, 2, 3, 5, Normal Termination.
Case 2: If an Exception raised in Statement 2 and Corresponding catch Block Matched  1, 4, 5, Normal Termination.
Case 3: If an Exception raised at Statement 2 and Corresponding catch Block Not Matched  1 followed by Abnormal Termination.
Case 4: If an Exception raised at Statement-4 OR Statement-5 then it’s Always Abnormal Termination.

Conclusions:
 Within the try Block if any where an Exception raised then Rest of the try Block won't be executed even though we handled that Exception.
 Hence within the try Block we have to Take Only Risky Code and Hence Length of the try Block should be as Less as Possible.
 If there is any Statement which raises an Exception and it is Not Part of the try Block then it is Always Abnormal Termination.
 In Addition to try Block there May be a Chance of raising an Exception Inside catch and finally Blocks Also.


Methods to Print Exception Information
Throwable Class defines the following Methods to Print Exception Information.

Method                                    Printed Format
printStackTrace()      Name of the Exception: Description Stack Trace

toString()            Name of the Exception: Description

getMessage()          Description



class Test {
public static void main(String[] args) {
try {
System.out.println(10/ 0);
}
catch (ArithmeticException e) {
e.printStackTrace(); //RE: java.lang.ArithmeticException: / by zero
at Test.main(Test.java:4)
System.out.println(e); //RE: java.lang.ArithmeticException: / by zero
System.out.println(e.getMessage()); /// by zero
}
}
}

Note: Internally Default Exception Handler Uses printStackTrace() to Print Exception Information to the Console.

try with Multiple catch Blocks -------------------------------------------------------------
The way of handling an Exception is varied from Exception to Exception.
Hence for Every Exception Type we have to define a Separate catch Block. Hence try with Multiple catch Blocks is Possible and Recommended to Use.

Not Recommended &&&&&&&&&&&&&&&&
try {
::::::::::::
::::::::::::
}
catch (Exception e) {
:::::::::::
:::::::::::
}


Recommended &&&&&&&&&&&&&&&&&&&&&&&&&
try {
::::::::::::::
::::::::::::::
}
catch (ArithmeticException e) {
//Perform these an Alternative ArithmeticException
}
catch (NullPointerException e) {
//Handling Related to null
}
catch (FileNotFoundException) {
//Use Local File Instead of Remote File
}
catch (SQLException e) {
//Use MySQL DB Instead of Oracle
}
catch (Exception e) {
Default Exception Handling
}



Note:
 If try with Multiple catch Blocks Present then the Order of catch Blocks are Very Important. It should be from Child to Parent.
 By Mistake if we are trying to Take Parent to Child then we will get Compile Time Error Saying: exception XXX has already been caught

try {}
catch (Exception e) {}
catch (ArithmeticException e) {} //CE: exception ArithmeticException has already been caught

try {}
catch (ArithmeticException e) {}
catch (Exception e) {}

For any Exception if we are writing 2 Same catch Blocks we will get Compile Time Error.

try {}
catch(ArithmeticException e) {}
catch(ArithmeticException e) {} //CE: error: exception ArithmeticException has already been caught


finally Block --------------------------------------
> It is Never Recommended to Define Clean-up Code Inside try Block. Because there is No Guaranty for the Execution of Every Statement Inside try Block.
> It is Never Recommended to Define Clean-up Code Inside catch Block. Because if there is No Exception then catch Block won't be executed.
> Hence we required Some Place to Maintain Clean-up Code which should be executed Always irrespective of whether Exception raised OR Not raised and whether Handled OR Not Handled. Such Type of Best Place is Nothing but finally Block.
> Hence the Main Objective of finally Block is to Maintain Clean-up Code.

try {
//Risky Code
}
catch(X e) {
//Handling Code
}
finally {
//Clean Up Code
}


> The Specialty of finally Block is it will be executed Always irrespective of whether Exception raised OR Not raised and whether Exception Handled OR Not Handled.

Example
class Test {
public static void main(String[] args) {
try {
System.out.println ("try");
}
catch (Exception e) {
System.out.println ("catch");
}
finally {
System.out.println ("finally");
}
}
}

try
finally 

try catch finally example
class Test {
public static void main(String[] args) {
try {
System.out.println ("try");
System.out.println (10/0);
}
catch (Exception e) {
System.out.println ("catch");
}
finally {
System.out.println ("finally");
}
}
}


try
catch
finally

class Test {
public static void main(String[] args) {
try {
System.out.println ("try");
System.out.println (10/0);
}
catch (NullPointerException e) {
System.out.println ("catch");
}
finally {
System.out.println ("finally");
}
}
}

try
finally
Exception in thread "main" java.lang.ArithmeticException: / by zero
at Test.main(Test.java:5)

finally Vs return:
If return Statement Present Inside try OR catch Blocks 1st finally will be executed and after that Only return Statement will be Considered i.e. finally Block Dominates return Statement.
class Test {
public static void main(String[] args) {
try {
System.out.println("try");
return;
}
catch(Exception e) {
System.out.println("catch");
}
finally {
System.out.println("finally");
}
}
}

try
finally

If try-catch-finally Blocks having return Statements then finally Block return Statement will be Considered
i.e. finally Block return Statement has More Priority than try and catch Block return Statements.


class Test {
public static void main(String[] args) {
System.out.println(m1()); //999
}
public static int m1() {
try {
return 777;
}
catch(Exception e) {
return 888;
}
finally {
return 999;
}
}
}

finally Vs System.exit(0): -----------------
There is Only One Situation where the finally Block won't be executed that is whenever we are System.exit(0).
Whenever we are using System.exit(0) then JVM itself will be Shutdown and hence finally Block won't be executed.
Note - That is System.exit(0) Dominates finally Block.

class Test {
public static void main(String[] args) { try {
System.out.println("try");
System.exit(0);
}
catch(Exception e) {
System.out.println("catch"); }
finally {
System.out.println("finally"); }
}
}

try

System.exit(0);
☀ We can Use this Method to Exit (Shut Down) the System (JVM) Programmatically.
☀ The Argument Represents as Status Code.
☀ Instead of 0 we can Pass any Valid int Value.
☀ 0 Means Normal Termination, Non- Zero Means Abnormal Termination.
☀ So this status code internally used by JVM.
☀ Whether it is 0 OR Non- Zero, Effect is Same in Our Program but this Number Internally used by JVM.


Difference between final, finally and finalize --------------------------------------------------

final:
> final is a Modifier is Applicable for Classes, Methods and Variables.
> If a Class declared as final then we can't Create Child Class. That is Inheritance is Not Possible for final Classes.
> If a Method declared as final then we can't Override that Method in Child Classes.
> If a Variable declared as final then we can't Perform Re- Assignment for that Variable.

finally:
> finally is a Block Always associated with try-catch to Maintain Clean Up Code.
> The Specialty of finally Block is it will be executed Always Irrespective of whether Exception raised OR Not and whether Handled OR Not Handled.

finalize():
> finalize() is a Method Always Called by the Garbage Collector Just before Destroying an Object to Perform Clean Up Activities.
> Once finalize() Completes Automatically Garbage Collector Destroys that Object.

Note:
 finalize() is Responsible to Perform Object Level Clean-Up Activities
whereas finally Block is Responsible to Perform try Block Level Clean-Up Activities
i.e. whatever Resources we Opened at the Time of try Block will be Closed Inside finally Block

> It is Highly Recommended to Use finally Block than finalize()because we can't Expect Exact Behavior of Garbage Collector.
It is JVM Vendor Dependent.


Control Flow in try - catch - finally:--------------------------------------


try {
System.out.println("Statement 1");
System.out.println("Statement 2");
System.out.println("Statement 3");
}
catch(X e) {
System.out.println("Statement 4");
}
finally {
System.out.println("Statement 5");
}
System.out.println("Statement 6");




Case 1: If there is No Exception. 1, 2, 3, 5 and 6  Normal Termination.
Case 2: If an Exception raised at Statement 2 and Corresponding catch Block Matched. then 1, 4, 5, 6  Normal Termination.
Case 3: If an Exception raised at Statement 2 and Corresponding catch Block Matched. then 1 and 5 Abnormal Termination.
Case 4: If an Exception raised at Statement 4 then it is Always Abnormal Termination but before that finally Block will be executed.
Case 5: If an Exception raised at Statement 5 OR Statement 6 then it is Always Abnormal Termination.


Control Flow in Nested try - catch - finally:
try {
System.out.println("Statement 1");
System.out.println("Statement 2");
System.out.println("Statement 3");
       try {
                System.out.println("Statement 4");
                System.out.println("Statement 5");
                System.out.println("Statement 6");
           }
       catch(X e) {
                System.out.println("Statement 7");
                  }
        finally {
                System.out.println("Statement 8");
                }


System.out.println("Statement 9");
}
catch(X e) {
System.out.println("Statement 10");
}
finally {
System.out.println("Statement 11");
}

System.out.println("Statement 12");

Case 1: If there is No Exception then 1, 2, 3, 4, 5, 6, and 8, 9, 11, 12 Normal Termination.
Case 2: If an Exception raised at Statement 2 and Corresponding catch Block Matched 1, 10, 11, and 12 Normal Terminations.
Case 3: If an Exception raised at Statement 2 and Corresponding catch Block is Not Matched 1 and 11 Abnormal Termination.
Case 4: If an Exception raised at Statement 5 and Corresponding Inner catch Block has Matched 1, 2, 3, 4, 7, 8, 9, 11, 12 Normal Termination.
Case 5: If an Exception raised at Statement 5 and Inner catch Block has Not Matched but Outer catch Block has Matched. 1, 2, 3, 4, 8, 10, 11, and 12 Normal Termination.
Case 6: If an Exception raised at Statement 5 and Both Inner and Outer catch Blocks are Not Matched then 1, 2, 3, 4, 8, and 11 Abnormal Termination.
Case 7: If an Exception raised at Statement 7 and Corresponding catch Block Matched 1, 2, 3,.,.,., 8, 10, 11, and 12 Normal Termination.
Case 8: If an Exception raised at Statement 7 and Corresponding catch Block Not Matched 1, 2, 3,.,.,.,8, and 11 Abnormal Termination.
Case 9: If an Exception raised at Statement 8 and Corresponding catch Block has Matched 1, 2, 3,.,.,.,., 10, 11, and 12 Normal Termination.
Case 10: If an Exception raised at Statement 8 and Corresponding catch Block Not Matched 1, 2, 3,.,.,.,., 11 Abnormal Termination.
Case 11: If an Exception raised at Statement 9 and Corresponding catch Block Matched 1, 2, 3,.,.,.,., 8, 10, 11, and 12 Normal Termination.
Case 12: If an Exception raised at Statement 9 and Corresponding catch Block Not Matched 1, 2, 3,.,.,.,.,8, and 11 Abnormal Termination.
Case 13: If an Exception raised at Statement 10 is Always Abnormal Termination but before that finally Block 11 will be executed.
Case 14: If an Exception raised at Statement 11 OR 12 it is Always Abnormal Termination.


Note:
> We can Take try – catch – finally Inside try Block i.e. Nesting of try – catch – finally is Always Possible.
> More Specific Exceptions can be handled by Inner catch Block and Generalized Exceptions are handled by Outer catch Blocks.
> Once we entered into the try Block without executing finally Block the Control Never Comes Up.
> If we are Not entering into the try Block then finally Block won’t be executed.

class Test {
public static void main(String[] args) {
try {
System.out.println(10/0);
}
catch(ArithmeticException e) {
System.out.println(10/0);
}
finally {
String s = null;
System.out.println(s.length());
}
}
}

Note: Default Exception Handler can Handle Only One Exception at a Time i.e. the Most Recently raised Exception.

Various Possible Combinations of try-catch-finally ----------------------------
> In try-catch-finally Order is Important.
> Inside try-catch-finally we can take try-catch-finally that is nesting of try-catch-finally is always possible.
> Whenever we are taking try Compulsory we have to Take either catch OR finally Blocks i.e. try without catch OR finally is Invalid.
> Whenever we are writing catch Block Compulsory we have to write try Block i.e. catch without try is Invalid.
> Whenever we are writing finally Block Compulsory we should write try i.e. finally without try is Invalid.
> For try-catch-finally Blocks Curly Braces are Mandatory.
> We can’t write 2 catch Blocks for the Same Exception Otherwise we will get CE.

try {}
catch (X e) {}

try {}
catch (X e) {}
catch (Y e) {}

try {}
catch (X e) {}
catch (X e) {} // CE: exception ArithmeticException has already been caught

try {}
finally {}

try {} //CE: 'try' without 'catch', 'finally' or resource declarations

finally {} //CE: 'finally' without 'try'

catch (X e) {} //CE: 'catch' without 'try'

try {} //CE: 'try' without 'catch', 'finally' or resource declarations
System.out.println("Hello");
catch {} //CE: 'catch' without 'try'

try {}
catch (X e) {}
System.out.println("Hello");
catch (Y e) {} //CE: 'catch' without 'try'

try {}
catch (X e) {}
System.out.println("Hello");
finally {} //CE: 'finally' without 'try'

try {}
finally {}
catch (X e) {} //CE: 'catch' without 'try'

try {}
catch (X e) {}
try {}
finally {}

try {}
catch (X e) {}
finally {}
finally {} //CE: 'finally' without 'try'


try {}
catch (X e) {
           try {}
           catch (Y e1) {}
}


try {}
catch (X e) {}
finally {
-         try {}
          catch (Y e1) {}
          finally {}
}


try {
try {} //CE: 'try' without 'catch', 'finally' or resource declarations
}
catch (X e) {}

try //CE: '{' expected
System.out.println("Hello");
catch (X e1) {} //CE: 'catch' without 'try'

try {}
catch (X e) //CE:'{' expected
System.out.println("Hello");


try {}
catch (NullPointerException e1) {}
finally //CE: '{' expected
System.out.println("Hello");


throw Keyword: ---------------------------------
> Sometimes we can Create Exception Object Explicitly and we can Handover Our Created Exception Object to the JVM Manually.
For this we have to Use throw key Word.
Eg:
throw new ArithmeticException("/by zero");

throw Key Word Handover Our Created Exception Objet to the JVM Manually
Creation of Exception Object Explicitly

In General we can Use throw Key Word for Customized Exceptions but Not for pre-defined Exceptions.
The Result of following 2 Programs is Exactly Same.

Case – 1 
class Test {
public static void main(String[] args) {
System.out.println(10/0);
}
}
//Exception in thread "main" java.lang.ArithmeticException: / by zero

Case – 2
class Test1 {
public static void main(String[] args) {
throw new ArithmeticException("/ by zero Explicitly");
}
}
//Exception in thread "main" java.lang.ArithmeticException: / by zero Explicitly

In the Case – 1 main() is Responsible to Create Exception Object and Handover to the JVM. This Total Activity will be performed Internally.
In the Case – 2 Programmer creating Exception Object Explicitly and Handover to the JVM Manually.
Hence the Main Purpose of throw Key Word is to Handover Our Created Exception Object to the JVM Manually.

Case 1: throw e;
If ‘e’ Refers ‘null’ then we will get NullPointerException.

class Test {
static ArithmeticException e = new ArithmeticException();
public static void main(String[] args) {
throw e;
}
}
RE: Exception in thread "main" java.lang.ArithmeticException

class Test {
static ArithmeticException e;
public static void main(String[] args) {
throw e;
}
}
//RE: Exception in thread "main" java.lang.NullPointerException


Case 2: After throw Statement we are Not allowed to write any Statements Directly Otherwise we will get Compile Time Error Saying unreachable statement.

class Test {
public static void main(String[] args) {
System.out.println(10/0);
System.out.println("Hello");
}
}
RE: Exception in thread "main" java.lang.ArithmeticException: / by zero

class Test {
public static void main(String[] args) {
throw new ArithmeticException("/by zero");
System.out.println("Hello"); //CE: unreachable statement
}
}

Case 3: We can Use throw Key Word Only for Throwable Types. Otherwise we will get Compile Time Error Saying incompatible types.
class Test {
public static void main(String[] args) {
throw new Test();
}
}

CE: incompatible types
required: Throwable
found: Test

class Test extends RuntimeException {
public static void main(String[] args) {
throw new Test();
}
}
RE: Exception in thread "main" Test

throws Key Word -------------------------------------------------------------------
In Our Program if there is any Chance of raising Checked Exception,
then Compulsory we should Handled that Checked Exception Otherwise we will get Compile Time Error
Saying unreported exception XXX; must be caught or declared to be thrown.

import java.io.PrintWriter;
class Test {
public static void main(String[] args) {
PrintWriter out = new PrintWriter("Abc.txt");
out.println("Hello");
}
}
CE: unreported exception FileNotFoundException; must be caught or declared to be thrown

class Test {
public static void main(String args[]) {
Thread.sleep(5000);
}
}
CE: unreported exception InterruptedException; must be caught or declared to be thrown

We can Handle this Compile Time Error in 2 Ways.
1) By Using try-catch
2) By Using throws Key Word

1st Way: By Using try – catch Block ------------------
class Test {
public static void main(String args[]) {
try {
Thread.sleep(5000); }
catch (InterruptedException e) {}
}
}


2nd Way: By Using throws Key Word
> We can use throws Key Word to Delegate the Responsibility of Exception Handling to the Caller Method (It May be Another Method OR JVM). Then Caller is Responsible to Handle that Checked Exception.
> throws Key Word required Only for Checked Exceptions.
> Usage of throws Key Word for Unchecked Exceptions there is No Use.
> throws Key Word required Only to Convince Compiler and it doesn’t Prevent Abnormal Termination of the Program.
> Hence Recommended to Use try- catch- finally Over throws Key Word.



class Test {
public static void main(String[] args)throws InterruptedException {
Thread.sleep(5000);
}
}

Conclusions:

throws
KeyWord

1) We can Use to Delegate the Responsibility of Exception Handling to the Caller.
2) It is required Only for Checked Exceptions and for Unchecked Exceptions there is No Use.
3) It is required Only to Convince Compiler and its Usage doesn’t Prevent Abnormal Termination of the Program.

class Test {
public static void main(String[] args)throws InterruptedException {
doStuff();
}
public static void doStuff()throws InterruptedException {
doMoreStuff();
}
public static void doMoreStuff()throws InterruptedException {
Thread.sleep(5000);
}
}

In the Above Program if we Remove at-least One throws Statement then the Code won't Compile. 
We will get CE: unreported exception InterruptedException; must be caught or declared to be thrown

Case 1: We can Use throws Key Word Only for Methods and Constructors but Not for Classes.
class Test throws Exception {
Test() throws Exception {} √
public static void m1() throws Exception {} √
}

Case 2:
We can Use throws Key Word Only for Throwable Types but Not for Normal Java Classes. Otherwise we will get Compile Time Error Saying
incompatible types
required: java.lang.Throwable
found: Test

class Test {
public static void main(String[] args) throws Test {}
}
CE: incompatible types
required: Throwable
found: Test

class Test extends RuntimeException/ Exception/ Throwable {
public static void main(String[] args) throws Test {}
} √

Case 3: -----------

class Test {
public static void main(String[] args) {
throw new Exception();  // checked Exception
}
}
CE: unreported exception Exception; must be caught or declared to be thrown


class Test {
public static void main(String[] args) {
throw new Error();  // unchecked Exception
}
}
RE: Exception in thread "main" java.lang.Error
at Test.main(Test.java:3)






























































