Actions API
ref- https://www.selenium.dev/documentation/webdriver/actions_api/ 
The Actions API in Selenium provides granular control over virtualized input devices (keyboard, mouse, pen, touch, scroll wheel) to simulate complex user interactions. 

Unlike high-level methods (e.g., element.click()), it allows precise sequencing of low-level actions, which are executed together via perform(). Here's a structured breakdown:

1. Input Sources


a. Keyboard (key_input)
Simulate key presses, releases, and typing.
Methods: key_down(key), key_up(key), send_keys(keys).
Example: Holding SHIFT to type uppercase

Actions actions = new Actions(driver);
actions.keyDown(Keys.SHIFT)
       .sendKeys("a")
       .keyUp(Keys.SHIFT)
       .perform(); // Outputs "A"


b. Pointer (pointer_input)
Models mouse, pen, or touch interactions.
Methods: move_to(element), click_and_hold(), release(), context_click() (right-click), double_click().
Example: Drag-and-drop:

WebElement source = driver.findElement(By.id("source"));
WebElement target = driver.findElement(By.id("target"));
new Actions(driver)
    .clickAndHold(source)
    .moveToElement(target)
    .release()
    .perform();

c. Wheel (wheel_input) (Selenium 4.2+)
Simulates scroll wheel actions.
Method: scrollByAmount(x, y).
Example: Scroll down 100 pixels:

new Actions(driver)
    .scrollByAmount(0, 100)
    .perform();

2. Chaining and Execution
Chain actions for one or more devices into a sequence.
Execution: Call perform() to run all actions atomically.
Example: Holding a key while moving the mouse:

new Actions(driver)
    .keyDown(Keys.CONTROL)
    .moveToElement(element)
    .click()
    .keyUp(Keys.CONTROL)
    .perform(); // Ctrl+Click

3. Advanced Use Cases
Multi-device coordination: Combine keyboard, pointer, and wheel actions.
Pen/Touch interactions: Specify pointer type during initialization:


PointerInput pen = new PointerInput(PointerInput.Kind.PEN, "my-pen");
new Actions(driver)
    .setActivePointer(pen)
    .moveToElement(canvas)
    .clickAndHold()
    .moveByOffset(50, 50) // Draw a line
    .release()
    .perform();

4. Key Notes
Order matters: Actions execute in the sequence they’re added.
No implicit waits: Add explicit waits if UI delays are expected.
Synchronization: Actions across devices are synchronized during perform().

5. When to Use the Actions API
Complex interactions (e.g., drag-and-drop, multi-touch, key combinations).
Precise control over input device behavior (e.g., simulating a pen’s pressure).
By leveraging the Actions API, you can replicate realistic user interactions for comprehensive testing.


Summary: Action Builder in Selenium
The transition from the legacy JSON Wire Protocol to the W3C WebDriver Protocol introduced highly granular control over input devices (keyboard, mouse, pen, wheel) in Selenium's Actions API. 

While this provides powerful low-level customization, it requires manual synchronization when coordinating multiple devices (e.g., keyboard shortcuts with mouse clicks).

However, most users do not need to interact directly with low-level commands, as Selenium offers pre-built convenience methods for common interactions (e.g., clicks, typing, drag-and-drop).

These methods abstract the underlying complexity, simplifying test automation.

Key Points:
W3C Protocol: Enables detailed control but increases complexity for multi-device synchronization.
Convenience Methods: Handle most use cases (e.g., click(), sendKeys(), scrollByAmount()), eliminating the need for manual low-level command chaining.
Documentation: Detailed guides for keyboard, mouse, pen, and wheel interactions are available in Selenium’s official docs.
Takeaway: Prioritize convenience methods for efficiency, reserving low-level commands for advanced, unsupported scenarios.

Pause
Pointer movements and Wheel scrolling allow the user to set a duration for the action, but sometimes you just need to wait a beat between actions for things to work correctly.
        WebElement clickable = driver.findElement(By.id("clickable"));
        new Actions(driver)
                .moveToElement(clickable)
                .pause(Duration.ofSeconds(1))
                .clickAndHold()
                .pause(Duration.ofSeconds(1))
                .sendKeys("abc")
                .perform();

> pointer movements and wheel scrolling have durations, but sometimes you need a pause between actions.
>the Pause method in Selenium allows inserting a wait between actions in the chain. Unlike duration parameters in movements or scrolls, which control the speed of the action, a Pause is a simple wait.

even though you can set durations for movements, sometimes you just need a delay between actions. For example, after clicking an element, you might need to wait for a dropdown to appear before moving the pointer again.

I should explain the difference between duration in movements and Pause. Duration spreads the action over time (like moving the mouse smoothly), while Pause is a static wait. It's important to note that Pause doesn't take a duration parameter but a time in milliseconds or a Java Duration object.


Use cases: When elements take time to load after an action, when animations need to finish, or when coordinating complex sequences where timing is crucial. However, I should also mention that using explicit waits (like WebDriverWait) is generally better than hard-coded pauses to avoid flaky tests. But in some cases, like when no condition can be checked, a Pause is necessary.



Explanation: Pause in Selenium Actions API
The pause(duration) method in Selenium's Actions API allows you to insert a deliberate wait between chained actions. Unlike the duration parameter in pointer movements or wheel scrolls (which controls the speed of an action), a pause adds a static delay to ensure proper timing or synchronization between steps.

>  When to Use pause():
1. Waiting for UI Updates:

After triggering an action (e.g., clicking a button), wait for a dropdown, modal, or animation to render.


new Actions(driver)  
    .click(button)  
    .pause(Duration.ofSeconds(1)) // Wait for dropdown to open  
    .sendKeys("Text")  
    .perform();  

Synchronizing Complex Sequences:

2. Coordinate multi-device actions (e.g., holding a key while hovering).

new Actions(driver)  
    .keyDown(Keys.SHIFT)  
    .moveToElement(element)  
    .pause(500) // Short delay before clicking  
    .click()  
    .keyUp(Keys.SHIFT)  
    .perform();  

3. Avoiding Timing Flakiness:
Handle scenarios where implicit/explicit waits aren’t sufficient (e.g., third-party animations).

Best Practices:
Avoid Overuse: Prefer explicit waits (e.g., WebDriverWait) for element readiness. Use pause() sparingly.
Keep Pauses Short: Use milliseconds (e.g., 500 ms) to minimize test execution time.
Combine with Action Durations: For realistic user behavior:

new Actions(driver)  
    .moveToElement(element, 1000) // Smooth 1-second movement  
    .pause(500) // Wait after moving  
    .click()  
    .perform();  

Example: Drag-and-Drop with Pauses

WebElement source = driver.findElement(By.id("source"));  
WebElement target = driver.findElement(By.id("target"));  

new Actions(driver)  
    .clickAndHold(source)  
    .pause(1000) // Wait to ensure the element is "grabbed"  
    .moveToElement(target)  
    .pause(500) // Wait before releasing  
    .release()  
    .perform();  

Key Takeaway
Use pause() to manage timing gaps between actions when dynamic waits (e.g., for element visibility) aren’t feasible. It’s a simple but powerful tool for stabilizing complex interaction chains in automation scripts.

Explanation: Release All Actions
In Selenium's Actions API, input devices (keyboard, mouse, etc.) retain their state (e.g., pressed keys, held mouse buttons) even between action chains. This can lead to unintended behavior if not properly reset. For example:
A key (e.g., SHIFT) remains depressed after a test, affecting subsequent actions.
A mouse button stays "held down," causing accidental drags or clicks in later steps.
The release_all_actions() method (or equivalent in your language) is a safety mechanism to reset all input states. Unlike actions queued with perform(), this method does not require chaining and is executed immediately.

Why Use release_all_actions()?
Prevent State Leakage:

Resets all keys and pointer buttons to their "up" state.
Example: If a test fails mid-action (e.g., after keyDown(Keys.SHIFT) but before keyUp()), subsequent tests inherit the SHIFT key being pressed.
Isolate Test Cases:

Ensures no lingering input states affect unrelated tests.
Handle Unexpected Interruptions:

Use in teardown/cleanup phases to guarantee a clean slate.
| Python | ActionChains(driver).reset_actions() | driver.reset_actions() |
| Java | Actions(driver).release()* | new Actions(driver).release().perform(); |
| C# | new Actions(driver).Release() | new Actions(driver).Release().Perform(); |
Note:

In Java, release() only releases the current action chain’s inputs. For a full reset, use driver.getKeyboard().releaseAllKeys() and driver.getMouse().releaseAllButtons().
Not part of perform(): Unlike regular actions, release_all_actions() is called directly and bypasses the queuing system.

        ((RemoteWebDriver) driver).resetInputState();

// Java example  
new Actions(driver)  
    .keyDown(Keys.CONTROL)  
    .click(element)  
    .perform();  

// Cleanup: Release all keys/buttons  
new Actions(driver).release().perform();  

When to Call release_all_actions()
After tests with partial actions (e.g., interrupted by exceptions).
Between independent test cases to ensure isolation.
Before navigating to a new page where lingering inputs could cause issues.

Keyboard actions--------------------

A representation of any key input device for interacting with a web page.
There are only 2 actions that can be accomplished with a keyboard: 
> pressing down on a key, and 
> releasing a pressed key.

In addition to supporting ASCII characters, each keyboard key has a representation that can be pressed or released in designated sequences.

Keys
In addition to the keys represented by regular unicode, unicode values have been assigned to other keyboard keys for use with Selenium. 
Each language has its own way to reference these keys; the full list can be found here.
ref - https://www.w3.org/TR/webdriver/#keyboard-actions 

Key down
        new Actions(driver)
                .keyDown(Keys.SHIFT)
                .sendKeys("a")
                .perform();


Key up

        new Actions(driver)
                .keyDown(Keys.SHIFT)
                .sendKeys("a")
                .keyUp(Keys.SHIFT)
                .sendKeys("b")
                .perform();


Send keys
This is a convenience method in the Actions API that combines keyDown and keyUp commands in one action. Executing this command differs slightly from using the element method, but primarily this gets used when needing to type multiple characters in the middle of other actions.

Active Element
        new Actions(driver)
                .sendKeys("abc")
                .perform();


Designated Element
        new Actions(driver)
                .sendKeys(textField, "Selenium!")
                .perform();


Copy and Paste

Here’s an example of using all of the above methods to conduct a copy / paste action. Note that the key to use for this operation will be different depending on if it is a Mac OS or not. This code will end up with the text: SeleniumSelenium!

        Keys cmdCtrl = Platform.getCurrent().is(Platform.MAC) ? Keys.COMMAND : Keys.CONTROL;

        WebElement textField = driver.findElement(By.id("textInput"));
        new Actions(driver)
                .sendKeys(textField, "Selenium!")
                .sendKeys(Keys.ARROW_LEFT)
                .keyDown(Keys.SHIFT)
                .sendKeys(Keys.ARROW_UP)
                .keyUp(Keys.SHIFT)
                .keyDown(cmdCtrl)
                .sendKeys("xvv")
                .keyUp(cmdCtrl)
                .perform();

        Assertions.assertEquals("SeleniumSelenium!", textField.getAttribute("value"));

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Mouse actions
A representation of any pointer device for interacting with a web page.
There are only 3 actions that can be accomplished with a mouse:
> pressing down on a button, 
> releasing a pressed button, and
> moving the mouse. 

Selenium provides convenience methods that combine these actions in the most common ways.

Click and hold

This method combines moving the mouse to the center of an element with pressing the left mouse button. This is useful for focusing a specific element:
        WebElement clickable = driver.findElement(By.id("clickable"));
        new Actions(driver)
                .clickAndHold(clickable)
                .perform();


Click and release

This method combines moving to the center of an element with pressing and releasing the left mouse button. This is otherwise known as “clicking”:

        WebElement clickable = driver.findElement(By.id("click"));
        new Actions(driver)
                .click(clickable)
                .perform();


Alternate Button Clicks
There are a total of 5 defined buttons for a Mouse:

0 — Left Button (the default)
1 — Middle Button (currently unsupported)
2 — Right Button
3 — X1 (Back) Button
4 — X2 (Forward) Button


Context Click

This method combines moving to the center of an element with pressing and releasing the right mouse button (button 2). This is otherwise known as “right-clicking”:

        WebElement clickable = driver.findElement(By.id("clickable"));
        new Actions(driver)
                .contextClick(clickable)
                .perform();

Back Click
There is no convenience method for this, it is just pressing and releasing mouse button 3


        PointerInput mouse = new PointerInput(PointerInput.Kind.MOUSE, "default mouse");

        Sequence actions = new Sequence(mouse, 0)
                .addAction(mouse.createPointerDown(PointerInput.MouseButton.BACK.asArg()))
                .addAction(mouse.createPointerUp(PointerInput.MouseButton.BACK.asArg()));

        ((RemoteWebDriver) driver).perform(Collections.singletonList(actions));


Forward Click
There is no convenience method for this, it is just pressing and releasing mouse button 4

        PointerInput mouse = new PointerInput(PointerInput.Kind.MOUSE, "default mouse");

        Sequence actions = new Sequence(mouse, 0)
                .addAction(mouse.createPointerDown(PointerInput.MouseButton.FORWARD.asArg()))
                .addAction(mouse.createPointerUp(PointerInput.MouseButton.FORWARD.asArg()));

        ((RemoteWebDriver) driver).perform(Collections.singletonList(actions));


Double click
This method combines moving to the center of an element with pressing and releasing the left mouse button twice.
        WebElement clickable = driver.findElement(By.id("clickable"));
        new Actions(driver)
                .doubleClick(clickable)
                .perform();

Move to element
This method moves the mouse to the in-view center point of the element. This is otherwise known as “hovering.” Note that the element must be in the viewport or else the command will error.

        WebElement hoverable = driver.findElement(By.id("hover"));
        new Actions(driver)
                .moveToElement(hoverable)
                .perform();


????????????????






*******************************************************************************************************************************
Actions class in selenium
> How to handle Actions class in Selenium
> Methods of Actions class
> Examples of Actions class

How to handle Actions class in Selenium
Use Actions Class in Selenium to Handle Keyboard & Mouse Events in Selenium. 

What is Actions Class in Selenium?
Actions class is an ability provided by Selenium for handling keyboard and mouse events.

Selenium WebDriver's Actions class provides a way to perform complex user interactions with web applications.
Here are some of the keyboard and mouse actions you can perform using the Actions class:

Mouse Actions
1. Click: Simulate a mouse click on an element. > actions.click(element).perform();
2. Double Click: Simulate a double-click on an element. > actions.doubleClick(element).perform();
3. Right Click (Context Click): Simulate a right-click on an element. > actions.contextClick(element).perform();
4. Mouse Hover: Move the mouse to an element (hover). > actions.moveToElement(element).perform();
5. Drag and Drop: Drag an element from one location and drop it to another. > actions.dragAndDrop(sourceElement, targetElement).perform();
6. Click and Hold: Click and hold the mouse button on an element. > actions.clickAndHold(element).perform();
7. Release: Release the mouse button after a click and hold. > actions.release(element).perform();
8. Move By Offset: Move the mouse to a specific offset from the current position. > actions.moveByOffset(xOffset, yOffset).perform();


Keyboard Actions
1. Send Keys: Send keystrokes to an element. > actions.sendKeys(element, "text").perform();
2. Key Down: Press and hold a key (e.g., Shift, Control). > actions.keyDown(Keys.SHIFT).perform();
3. Key Up: Release a key that was previously pressed. > actions.keyUp(Keys.SHIFT).perform();
4. Combination of Keys: Perform a combination of keys (e.g., Ctrl + A). > actions.keyDown(Keys.CONTROL).sendKeys("a").keyUp(Keys.CONTROL).perform();
5. Pressing Special Keys: Send special keys like Enter, Escape, etc. > actions.sendKeys(Keys.ENTER).perform();

Chaining Actions
You can chain multiple actions together to perform a sequence of actions in one go:
actions.moveToElement(element)
       .click()
       .sendKeys("text")
       .build()
       .perform();

Conclusion
These actions can be combined and customized to simulate a wide range of user interactions, making the Actions class a powerful tool for testing web applications with Selenium WebDriver.

Examples of Actions Class in Selenium
1. Perform Click Action on the Web Element
Test Scenario: Visit the Browserstack home page and click on the Get Started Free button.

 public static void clickOnWebElementUsingActionsClass(){
        WebDriverManager.chromedriver().setup();
        WebDriver driver = new ChromeDriver();
        driver.manage().window().maximize();
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));
        driver.get("https://www.browserstack.com");
        Actions action = new Actions(driver);
        WebElement element = driver.findElement(By.linkText("Get started free"));
        action.moveToElement(element).click().build().perform();
    }


2. Perform Mouse Hover Action on the Web Element
Test Scenario: Perform Mouse Hover on Live Tab and App Automate Tab on the Browserstack Website.

  public static void mouseHoverActionOnWebElementUsingActionsClass() throws InterruptedException {
        WebDriverManager.chromedriver().setup();
        WebDriver driver = new ChromeDriver();
        driver.manage().window().maximize();
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));
        driver.get("https://www.browserstack.com");

        // scroll to the element on webpage to make it visible
        ((JavascriptExecutor) driver).executeScript("scroll(0,300)");

        Actions action = new Actions(driver);
        WebElement live = driver.findElement(By.xpath("(//a[@title='Live'])[3]"));
        action.moveToElement(live).build().perform();

        Thread.sleep(3000);

        WebElement automate = driver.findElement(By.xpath("(//a[@title='Automate'])[3]"));
        automate.click(); // not using Actions class here to click

        Thread.sleep(2000);
    }

Example 2
 public static void mouseHoverActionOnTopMenuActionsClass() throws InterruptedException {
        WebDriverManager.chromedriver().setup();
        WebDriver driver = new ChromeDriver();
        driver.manage().window().maximize();
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));
        driver.get("https://www.browserstack.com");
        // scroll to the element on webpage to make it visible
        ((JavascriptExecutor) driver).executeScript("scroll(0,300)");

        Actions action = new Actions(driver);
        WebElement productCategory = driver.findElement(By.xpath("//button[@id='products-dd-toggle']"));
        action.moveToElement(productCategory).build().perform();

        Thread.sleep(3000);

        WebElement live = driver.findElement(By.xpath("(//a[@title='Live'])[1]"));
        action.moveToElement(live).click().build().perform();

        Thread.sleep(2000);
    }

3. Perform Double Click Action on the Web Element
Test Scenario: Perform Double Click Action on Free Trial Button in the Browserstack Home page.

public static void doubleClickActionUsingActionsClass() throws InterruptedException {
        WebDriverManager.chromedriver().setup();
        WebDriver driver = new ChromeDriver();
        driver.manage().window().maximize();
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));
        driver.get("https://www.browserstack.com");

        Actions action = new Actions(driver);
        WebElement trialaction = driver.findElement(By.xpath("//a[@title='Free Trial']"));
        action.doubleClick(trialaction).perform();
    }


Keyboard actions
ref- https://www.selenium.dev/documentation/webdriver/actions_api/keyboard/ 
A representation of any key input device for interacting with a web page.
There are only 2 actions that can be accomplished with a keyboard:
> pressing down on a key,
> and releasing a pressed key.

In addition to supporting ASCII characters, each keyboard key has a representation that can be pressed or released in designated sequences.
Keys
In addition to the keys represented by regular unicode, unicode values have been assigned to other keyboard keys for use with Selenium.
Each language has its own way to reference these keys; the full list can be found here.
https://www.w3.org/TR/webdriver/#keyboard-actions

Use the Java Keys enum
https://github.com/SeleniumHQ/selenium/blob/selenium-4.2.0/java/src/org/openqa/selenium/Keys.java#L28

ref - https://github.com/SeleniumHQ/seleniumhq.github.io/blob/trunk/examples/java/src/test/java/dev/selenium/actions_api/KeysTest.java#L30-L35

Key down
        new Actions(driver)
                .keyDown(Keys.SHIFT)
                .sendKeys("a")
                .perform();


Key up

        new Actions(driver)
                .keyDown(Keys.SHIFT)
                .sendKeys("a")
                .keyUp(Keys.SHIFT)
                .sendKeys("b")
                .perform();


Send keys
This is a convenience method in the Actions API that combines keyDown and keyUp commands in one action. Executing this command differs slightly from using the element method, but primarily this gets used when needing to type multiple characters in the middle of other actions.

Active Element
  new Actions(driver)
                .sendKeys("abc")
                .perform();

Designated Element
        new Actions(driver)
                .sendKeys(textField, "Selenium!")
                .perform();
Copy and Paste
Here’s an example of using all of the above methods to conduct a copy / paste action. Note that the key to use for this operation will be different depending on if it is a Mac OS or not. This code will end up with the text: SeleniumSelenium!

        Keys cmdCtrl = Platform.getCurrent().is(Platform.MAC) ? Keys.COMMAND : Keys.CONTROL;

        WebElement textField = driver.findElement(By.id("textInput"));
        new Actions(driver)
                .sendKeys(textField, "Selenium!")
                .sendKeys(Keys.ARROW_LEFT)
                .keyDown(Keys.SHIFT)
                .sendKeys(Keys.ARROW_UP)
                .keyUp(Keys.SHIFT)
                .keyDown(cmdCtrl)
                .sendKeys("xvv")
                .keyUp(cmdCtrl)
                .perform();

        Assertions.assertEquals("SeleniumSelenium!", textField.getAttribute("value"));

In the article about Actions Class in Selenium, we discussed that Selenium provides a feature to handle keyboard events where user gestures can emulate. For example, suppose you search "India" on google search engine. For this, you will type "India " and press the Enter key, so that you see the result queries. 

Say, you want to automate this google search using the Selenium test, how will you simulate pressing the ENTER key using selenium code? 
The provision of the capability to simulate such keyboard actions is by the keyboard events generated using the Actions class of Selenium WebDriver. 

Here, we will cover the details of all the Keyboard events supported by Selenium. 
Additionally, we will also see how Actions class fit for the need of simulating the keyboard events in Selenium.

What are keyboard events in Selenium?
A Keyboard Event describes a user's interaction with the keyboard. When a user presses single or multiple keys, keyboard events generate.

Note:
Selenium provides various ways to automate these Keyboard Events, a few of which are:

> Automate keyboard events using the sendKeys() method of WebElement class.
> Automate keyboard events using Robot class.
> And Automate keyboard events using Actions class.

We already discussed the first two ways of handling the keyboard events using the "sendKeys()" method of WebDriver's WebElement class and "Robot class" in the articles given by corresponding links. 

In this article, we will specifically cover the details of the "Actions " class in Selenium WebDriver.


Why is Actions class needed to perform Keyboard actions using Selenium WebDriver?
When we interact with a web application, there will be various scenarios when the user performs the following actions:

Type in capital/Camel case letters: Wherever user need to type a word or letter in caps, he/she will press the "SHIFT" key and will type the necessary characters, and whatever characters will type while pressing the "SHIFT" key, will type as a capital letter.

Copy & Paste Text: When we need to copy some text from one text box to another, we select the text by pressing "CTRL+A" they copy the text using "CTRL+C" and paste the text in the new text box by simply clicking in the text box and pressing keys "CTRL+V".

These are very common user actions, which we perform on an almost daily basis. Now, as we discussed, Selenium WebDriver provides two ways to send any keyboard event to a web element:

sendKeys() method of WebElement class.
Actions class
Now let's try to understand in detail that if we want to automate the scenario as mentioned above of typing the letters in the capital (with SHIFT key pressed ), using the sendKeys() method of the WebElement class.

Consider the following scenario for quickly understanding the behavior:

First, navigate to "https://demoqa.com/text-box."
Secondly, enter the Full name: "Mr.Peter Haynes".
Thirdly, enter the Email: "PeterHaynes@toolsqa.com."
After that, Enter the Current Address: "43 School Lane London EC71 9GO".
Fifthly, click on the Current Address text box and Copy the Current Address.
After that, paste the copied address in the Permanent Address text box.
Finally, validate that the text in the Current Address and Permanent Address is the same.

Let's try to automate the above scenario using the sendKeys() method of the WebElement class:

package automationFramework;

import static org.junit.Assert.assertEquals;

import org.openqa.selenium.By;
import org.openqa.selenium.Keys;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;

public class KeyboardEvents {

	public static void main(String[] args) {
		
        // Initialize ChromeDriver
	// Here we assume that the ChromeDriver path has been set in the System Global variables
        WebDriver driver=new ChromeDriver();
       
        //Navigate to the demo site
        driver.get("https://demoqa.com/text-box");
       
        // Enter the Full Name
        WebElement fullName = driver.findElement(By.id("userName"));
        fullName.sendKeys("Mr.Peter Haynes");
        
        //Enter the Email
        WebElement email=driver.findElement(By.id("userEmail"));
        email.sendKeys("PeterHaynes@toolsqa.com");
        
        // Enter the Current Address
        WebElement currentAddress=driver.findElement(By.id("currentAddress"));
        currentAddress.sendKeys("43 School Lane London EC71 9GO");
        
        // Copy the Current Address
        currentAddress.sendKeys(Keys.CONTROL);
        currentAddress.sendKeys("A");
        currentAddress.sendKeys(Keys.CONTROL);
        currentAddress.sendKeys("C");
        
        //Press the TAB Key to Switch Focus to Permanent Address
        currentAddress.sendKeys(Keys.TAB);
        
        //Paste the Address in the Permanent Address field
        WebElement permanentAddress=driver.findElement(By.id("permanentAddress"));
        permanentAddress.sendKeys(Keys.CONTROL);
        permanentAddress.sendKeys("V");
        
        //Compare Text of current Address and Permanent Address
        assertEquals(currentAddress.getAttribute("value"),permanentAddress.getAttribute("value"));
        
        driver.close();

	}
}

In the above code snippet, though the sendKeys() method of WebElementallows using the Control Key, it cannot do the copy and paste action, as it fails to combine the key sequences.

As we can see from the following screenshot, instead of pasting the content of Current Address in the Permanent Address text field, it just pasted the character "V".

As is clear from the above screenshot, that the text of the Current Address text field did not copy to the Permanent Address text field, so it leads to failure of the assertion when the comparison of the text of these two fields happens. So, when we execute the above test, it fails with the following error message:

So, this is where the sendKeys() method of the WebElement class fails. In other words, it fails when we need to combine special keys such as "SHIFT", "CONTROL", etc. with the different key sequences, which we all know, is a prevalent scenario when we as a user are using any of the web applications.

Therefore, this is where the Actions class of Selenium WebDriver comes into the picture, which provides various methods to specifically handle operations of these meta keyboard keys, which need to press while performing operations on the other keyboard keys. 

Let's see how we can handle such keyboard actions, using the Actions class of Selenium WebDriver.

What is Actions Class in Selenium WebDriver?
As we discussed above, Selenium WebDriver provides a class named "Actions", which provides various methods that can help in automating and simulating the Keyboard and Mouse actions. 

Let's understand the Keyboard specific methods provided by the Actions Class:

What are the different methods provided by the Actions class for Keyboard Events?
As highlighted in the above screenshot, the Actions class majorly provide the following three methods for simulating the Keyboard events:

sendKeys(): 
This method sends a series of keystrokes to a given web element. This method has two overloaded formats:

1. sendKeys(CharSequence... KeysToSend): 
   The following screenshot shows the syntactical details of this method:
   This method sends a sequence of keys to a currently focused web element, i.e., if we want to send specific characters to a web element, that element must be first 
   focussed, then only the mentioned characters will go to that web element.

2. sendKeys(WebElement element, CharSequence... KeysToSend): 
   This implementation of the sendKeys() method sends a sequence of characters/keys to a specific web element, which passes as the first parameter to the method. This 
   method first focuses on the target web element and then performs the same action as sendKeys(CharSequence keys).


keyDown(): 
This method simulates a keyboard action when a specific keyboard key needs to press. So, whenever you need to press a key and
then perform specific other actions, we can use the keyDown() method to keep the key pressed. 

E.g., say a user has to type some characters in Capital. Then to simulate user behavior, where the user presses the SHIFT  key and then presses the set of characters that need to type in Capital. 

This method is also available in the following two overloaded variants:

1. keyDown(CharSequence key):
   This method presses the specified key on the currently focussed Web Element. This method generally presses the "Modifier keys" such as SHIFT, CTRL, etc. 
   If you want to press the keyboard key on a specified web element, then that web element first needs to be focussed explicitly,
   and then this method needs to be invoked.

2. keyDown(WebElement element, CharSequence key):
   This method first focusses on the web element, which has been passed as a parameter to the method and presses the mentioned key on that Web Element.

keyUp(): 
We use this method majorly in collaboration with the keyDown() method. 
The keyboard key which presses using the keyDown() method, doesn't get released automatically, so the same need to be explicitly released using the keyUp() method. 

So, similar to the keyDown() method, this method has two overloaded variants:

1. keyUp(CharSequence key):
   This method releases the specified key on the currently focussed Web Element. If you want to release the keyboard key on a specified web element, then that web 
   element first needs to be focussed explicitly, and then this method needs to be invoked.

2. keyUp(WebElement element, CharSequence key): 
   This method first focusses on the web element, which gets passed as a parameter to the method. Then, it releases the mentioned key on that Web Element.

Example
 public static void copyPasteUsingActionsClass() throws InterruptedException {
        WebDriverManager.chromedriver().setup();
        WebDriver driver = new ChromeDriver();
        driver.manage().window().maximize();
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));


        //Navigate to the demo site
        driver.get("https://demoqa.com/text-box");

        //Create object of the Actions class
        Actions actions = new Actions(driver);


        // Enter the Full Name
        WebElement fullName = driver.findElement(By.id("userName"));
        fullName.sendKeys("Mr.Peter Haynes");

        //Enter the Email
        WebElement email=driver.findElement(By.id("userEmail"));
        email.sendKeys("PeterHaynes@toolsqa.com");


        // Enter the Current Address
        WebElement currentAddress=driver.findElement(By.id("currentAddress"));

        currentAddress.sendKeys("43 School Lane London EC71 9GO");


        // Select the Current Address using CTRL + A
        actions.keyDown(Keys.CONTROL);
        actions.sendKeys("a");
        actions.keyUp(Keys.CONTROL);
        actions.build().perform();

        // Copy the Current Address using CTRL + C
        actions.keyDown(Keys.CONTROL);
        actions.sendKeys("c");
        actions.keyUp(Keys.CONTROL);
        actions.build().perform();

        //Press the TAB Key to Switch Focus to Permanent Address
        actions.sendKeys(Keys.TAB);
        actions.build().perform();

        //Paste the Address in the Permanent Address field using CTRL + V
        actions.keyDown(Keys.CONTROL);
        actions.sendKeys("v");
        actions.keyUp(Keys.CONTROL);
        actions.build().perform();


        //Compare Text of current Address and Permanent Address
        //WebElement permanentAddress=driver.findElement(By.id("permanentAddress"));
        //assertEquals(currentAddress.getAttribute("value"),permanentAddress.getAttribute("value"));


    }


How to handle contiguous Keyboard Actions using Actions Class?
As noticed in the above sections, all the methods of the Actions class briefed above returns an object of the Actions class only.

So, this gives us the flexibility of using the "Chaining of Methods", where we can club all the method invocations specific to one operation in one line of code only.

Let's modify the above-written code to trim it down further. We will use the Chaing of Methods  and will handle the various contiguous Keyboard operations in a single go:

 public static void KeyboardEventsUsingActions() {
        WebDriverManager.chromedriver().setup();
        WebDriver driver = new ChromeDriver();
        driver.manage().window().maximize();
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));
        //Navigate to the demo site
        driver.get("https://demoqa.com/text-box");
        //Create object of the Actions class
        Actions actions = new Actions(driver);
        // Enter the Full Name
        WebElement fullName = driver.findElement(By.id("userName"));
        fullName.sendKeys("Mr.Peter Haynes");
        //Enter the Email
        WebElement email = driver.findElement(By.id("userEmail"));
        email.sendKeys("PeterHaynes@toolsqa.com");
        // Enter the Current Address
        WebElement currentAddress = driver.findElement(By.id("currentAddress"));
        currentAddress.sendKeys("43 School Lane London EC71 9GO");
        // Select the Current Address
        actions.keyDown(Keys.CONTROL).sendKeys("a").keyUp(Keys.CONTROL).build().perform();
        // Copy the Current Address
        actions.keyDown(Keys.CONTROL).sendKeys("c").keyUp(Keys.CONTROL).build().perform();
        //Press the TAB Key to Switch Focus to Permanent Address
        actions.sendKeys(Keys.TAB).build().perform();
        //Paste the Address in the Permanent Address field
        actions.keyDown(Keys.CONTROL).sendKeys("v").keyUp(Keys.CONTROL).build().perform();
        //Compare Text of current Address and Permanent Address
        // WebElement permanentAddress=driver.findElement(By.id("permanentAddress"));
        // assertEquals(currentAddress.getAttribute("value"),permanentAddress.getAttribute("value"));

    }


Note- The only difference between the two is that this code looks more compact and easy to read. So, this way, we can combine various methods of the Actions class. Additionally, we can simulate user behavior for different Keyboard actions.

Key Takeaways
Keyboard events are the events that any of the Keyboard keys generate.
Additionally, they are a must to simulate the user behavior while automating a web application using Selenium WebDriver
The Actions Class of Selenium WebDriver provides - sendKeys(),keyUp(),keyDown() methods to handle various keyboard actions
The modifier key is never released implicitly after the keyDown() method - either we should call the keyUp(theKey) or sendKeys(Keys.NULL) to release the modifier.



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
1. public Actions keyDown(CharSequence key)
2. public Actions keyDown(WebElement target, CharSequence key)
3. public Actions keyUp(CharSequence key)
4. public Actions keyUp(WebElement target, CharSequence key)
5. public Actions sendKeys(CharSequence... keys)
6. public Actions sendKeys(WebElement target, CharSequence... keys)
7. private Actions sendKeysInTicks(CharSequence... keys)
8. private Actions addKeyAction(CharSequence key, IntConsumer consumer)
9. public Actions clickAndHold(WebElement target)
10. public Actions clickAndHold()
11. public Actions release(WebElement target)
12. public Actions scrollToElement(WebElement element)
13. public Actions scrollByAmount(int deltaX, int deltaY)
14. public Actions scrollFromOrigin(WheelInput.ScrollOrigin scrollOrigin, int deltaX, int deltaY) 
15. public Actions release()
16. public Actions click(WebElement target)
17. public Actions click()
18. private Actions clickInTicks(PointerInput.MouseButton button)
19. private Actions focusInTicks(WebElement target)
20. public Actions doubleClick(WebElement target)
21. public Actions doubleClick()
22. public Actions moveToElement(WebElement target)
23. public Actions moveToElement(WebElement target, int xOffset, int yOffset)
24. private Actions moveInTicks(WebElement target, int xOffset, int yOffset)
25. public Actions moveByOffset(int xOffset, int yOffset)
26. public Actions moveToLocation(int xCoordinate, int yCoordinate)
27. public Actions contextClick(WebElement target)
28. public Actions contextClick()
29. public Actions dragAndDrop(WebElement source, WebElement target)
30. public Actions dragAndDropBy(WebElement source, int xOffset, int yOffset)
31. public Actions pause(long pause)
32. public Actions pause(Duration duration)
33. public Actions tick(Interaction... actions)
34. public Actions setActiveKeyboard(String name)
35. public Actions setActivePointer(PointerInput.Kind kind, String name)
36. public Actions setActiveWheel(String name)
37. public KeyInput getActiveKeyboard()
38. public PointerInput getActivePointer()
39. public WheelInput getActiveWheel()
40. public Duration getActionDuration()
41. public Action build()
42. public void perform()
43. private Sequence getSequence(InputSource source)
44. public Collection<Sequence> getSequences()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
































































































































































































































